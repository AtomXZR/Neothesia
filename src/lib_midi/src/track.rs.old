use rimd::Status;
use std::collections::HashMap;

#[derive(Debug, Clone)]
pub struct MidiNote {
    pub start: f64,
    pub duration: f64,
    pub note: u8,
    pub vel: u8,
    pub ch: u8,
    pub track_id: usize,
}

#[derive(Clone)]
pub struct MidiTrack {
    pub tempo: u32,
    u_per_quarter_note: f64,
    u_time: f64,
    pub time_signature: f64,
    pub has_tempo: bool,
    pub seconds_per_measure: f64,
    pub notes: Vec<MidiNote>,
}

impl MidiTrack {
    pub fn new(track: &Vec<midly::Event>, u_per_quarter_note: u16) -> MidiTrack {
        let mut tempo = 0x555555;
        let mut time_signature = 4.0 / 4.0;

        // let mut events: Vec<rimd::TrackEvent> = Vec::new();
        // let mut events: Vec<midly::Event> = track.to_owned(); // Clone For Later Use In Note Extraction

        use midly::EventKind;
        use midly::MetaMessage;

        for event in track.iter() {
            match &event.kind {
                EventKind::Meta(meta) => match &meta {
                    MetaMessage::Tempo(t) => {
                        tempo = t.as_int();
                        // let bpm = 60_000_000 / tempo as u64;
                        // println!("BPM {}", bpm);
                    }
                    MetaMessage::TimeSignature(data0, data1, _, _) => {
                        time_signature =
                            data0.to_owned() as f64 / u32::pow(2, data1.to_owned() as u32) as f64;
                    }
                    _ => {}
                },
                _ => {}
            };
        }

        let u_per_quarter_note = u_per_quarter_note as f64;
        let u_time = tempo as f64 / u_per_quarter_note;
        let has_tempo = tempo != 0x555555;

        let seconds_per_measure = MidiTrack::measure_duration(tempo, time_signature);

        MidiTrack {
            tempo,
            u_per_quarter_note,
            u_time,
            time_signature,
            has_tempo,
            seconds_per_measure,
            notes: Vec::new(),
        }
    }

    fn measure_duration(tempo: u32, time_signature: f64) -> f64 {
        return tempo as f64 * 4.0 * time_signature / 1000000.0;
    }


    pub fn update_metrics(&mut self, tempo: u32, time_signature: f64) {
        self.tempo = tempo;
        self.u_time = tempo as f64 / self.u_per_quarter_note;

        self.seconds_per_measure = MidiTrack::measure_duration(self.tempo, self.time_signature);
        self.seconds_per_measure /= self.time_signature;
        self.time_signature = time_signature;
        self.seconds_per_measure *= self.time_signature;
    }

    pub fn extract_notes(&mut self, events: &Vec<midly::Event>, lower_bound: u8, higher_bound: u8) {
        self.notes.clear();

        let mut time_in_units = 0.0;

        struct Note {
            time_in_units: f64,
            vel: u8,
            channel: u8,
        };
        let mut current_notes: HashMap<u8, Note> = HashMap::new();
        // println!("NEW TRACK");
        let mut index = 0;
        for event in events.iter() {
            use midly::EventKind;
            use midly::MetaMessage;
            use midly::MidiMessage;

            match &event.kind {
                EventKind::Midi { channel, message } => {
                    time_in_units += event.delta.as_int() as f64;
                    // println!("time_in_units:{}", time_in_units);
                    match &message {
                        MidiMessage::NoteOn(data0, data1) => {
                            let data0 = data0.as_int();
                            let data1 = data1.as_int();
                            if data1 > 0 && data0 >= lower_bound && data0 <= higher_bound {
                                let k = data0 - lower_bound;
                                current_notes.insert(
                                    k,
                                    Note {
                                        time_in_units: time_in_units,
                                        vel: data1,
                                        channel: channel.as_int(),
                                    },
                                );
                            // println!("{:?}", current_notes.get(&k).unwrap());
                            } else if data1 == 0 {
                                let k = data0 - lower_bound;

                                if current_notes.contains_key(&k) {
                                    let n = current_notes.get(&k).unwrap();

                                    let start = self.u_time * n.time_in_units;
                                    let duration = self.u_time * time_in_units - start;

                                    let mn = MidiNote {
                                        start: start / 1000000.0,
                                        duration: duration / 1000000.0,
                                        note: k,
                                        vel: n.vel,
                                        ch: channel.as_int(),
                                        track_id: 0, // Placeholder
                                    };

                                    // let bpm = 60_000_000 / self.tempo as u64;
                                    // println!("N:{} BPM {}", mn.note, bpm);
                                    // println!("{:?}", mn);
                                    self.notes.push(mn);
                                }
                            }

                        }
                        MidiMessage::NoteOff(data0, data1) => {
                            let data0 = data0.as_int();

                            let k = data0 - lower_bound;

                            if current_notes.contains_key(&k) {
                                let n = current_notes.get(&k).unwrap();

                                let start = self.u_time * n.time_in_units;
                                let duration = self.u_time * time_in_units - start;

                                let mn = MidiNote {
                                    start: start / 1000000.0,
                                    duration: duration / 1000000.0,
                                    note: k,
                                    vel: n.vel,
                                    ch: channel.as_int(),
                                    track_id: 0, // Placeholder
                                };

                                // let bpm = 60_000_000 / self.tempo as u64;
                                // println!("N:{} BPM {}", mn.note, bpm);
                                // println!("{:?}", mn);
                                self.notes.push(mn);
                            }

                        }
                        MidiMessage::ProgramChange(_data0) => {
                            time_in_units -= event.delta.as_int() as f64;
                            // println!("{} ProgramChange", index);
                        }
                        _ => {}
                    }
                }
                EventKind::Meta(meta) => match &meta {
                    MetaMessage::Tempo(t) => {
                        self.tempo = t.as_int();
                        self.u_time = self.tempo as f64 / self.u_per_quarter_note;

                        self.seconds_per_measure =
                            MidiTrack::measure_duration(self.tempo, self.time_signature);

                        let bpm = 60_000_000 / self.tempo as u64;
                        println!("BPM {}", bpm);
                    }
                    MetaMessage::TimeSignature(data0, data1, _, _) => {
                        self.seconds_per_measure /= self.time_signature;
                        self.time_signature =
                            data0.to_owned() as f64 / u32::pow(2, data1.to_owned() as u32) as f64;
                        self.seconds_per_measure *= self.time_signature;
                    }
                    _ => {}
                },
                _ => {}
            }
        }

        self.notes
            .sort_by(|a, b| a.start.partial_cmp(&b.start).unwrap());
    }
}
